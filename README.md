# Правила компиляции C++ на Linux
### Во всех случаях используем компилятор g++

## Для обычной компиляции:
```
g++ -c File1.cpp File2.cpp ...
g++ File1.o File2.o ... -o result
```
## Для обычной компиляции в одну команду:
```g++ File1.cpp File2.cpp ... -o result```
## Для компиляции через make в Makefile прописываем:
```
IF1 = File1.cpp
IF2 = File2.cpp
...
RES = result

all:
	g++ $(IF1) $(IF2) ... -o $(RES)
run:
	./$(RES)
clean:
	rm $(RES)
```
## Для ПОЛНОЙ пошаговой компиляции(каждый шаг, кроме последнего, нужно выполнять отдельно для каждого файла):
### Препроцессинг (замена команд по типу #include и #define):
```g++ -E File1.cpp -o pre.ii```
### Компиляция (в ассемблерный код): 
```g++ -S pre.ii -o asm.asm```
### Ассемблирование (в машинный код):
```as asm.asm -o mc.o ```
### Компоновка-линковка (в исполняемый файл):
```g++ mc.o mc2.o ... -o result```

## Флаги компиляции:
**-Iпуть/к/заголовочным/файлам** - указывает путь к .h файлам

**-lназвание_библиотеки** - линковка с библиотекой

**-Lпуть/к/файлам/библиотек** - указывает путь к .so и .a файлам библиотек

**-Wall** - включает больше предпреждений

**-Werror** - превращает предупреждения в ошибки компиляции, рекомендуется использование с **-Wall**

**-o название_файла** - сохраняет результат в указанный файл

**-O(1-3 или Fast)** - чем больше цифра, тем дольше компиляция и лучше оптимизация, **-OFast** лучше **-O3**

**-с** - компиляция в .o файл(объектный код)

**-static** - повышает размер файла, но делает его независимым от наличия библиотек в системе(проверить на статичность можно командой **ldd название_полученного_файла**, в случае динамичности файла покажет, к каким библиотекам тот привязан и где они находятся)

**-std=c++(11, 14, 17, 20)** - выбор стандарта C++, если хочется строгого соответсвия стандарту, то пишем флаг **-pedantic**


## Разница между статической(.a) и динамической(.so) библиотекой:
Статическая библиотека — это архив объектных файлов (.o), которые линкуются с кодом. Весь код из статической библиотеки включается в итоговый файл.
Динамические библиотеки — это отдельные файлы, которые загружаются в память во время выполнения программы. Они не включаются в иитоговый файл, а подключаются уже на этапе выполнения.
У статических размер итогового файла выше и при выходе новой версии придется все перекомпилировать, у динамических размер меньше, но работают они медленее, а также при выходе новой версии можно обойтись без перекомпилирования проекта.
Статические бибилотеки подходят для одного проекта, динамические же, для многих других проектов.
Использование в проекте у всех вариантов стандартное, #include <LibFile.h>

## Компиляция статической библиотеки:
```
g++ -c LibFile.cpp
ar rcs liblibfile.a LibFile.o
g++ File.cpp -L. -llibfile -o result
```

(-L. указывает на то, что библиотека и проект находятся в одном каталоге)
### Через make:
```
LF = LibFile
IF = File.cpp
RES = result
PREF = /usr/local

all:
	g++ -c $(LF).cpp
	ar rcs lib$(LF).a $(LF).o
run:
	g++ $(IF) -o $(RES) -l$(LF) -static
	./$(RES)
install:
	sudo cp $(LF).h $(PREF)/include
	sudo cp lib$(LF).a $(PREF)/lib
	sudo ldconfig
uninstall:
	sudo rm -f $(PREF)/include/$(LF).h
	sudo rm -f $(PREF)/lib/lib$(LF).a
	sudo ldconfig
clean:
	rm $(LF).o lib$(LF).a
cleanall:
	rm $(LF).o $(RES) lib$(LF).a
```

## Компиляция динамической бибилотеки:
```
g++ -c LibFile.cpp -fPIC
g++ -shared LibFile.o -o libLibFile.so
g++ File.cpp -o result -lLibFile
```
### Через make:
```
LF = LibFile
IF = File.cpp
RES = result
PREF = /usr/local

all:
	g++ -c $(LF).cpp -fPIC
	g++ -shared $(LF).o -o lib$(LF).so
run:
	g++ $(IF) -o $(RES) -l$(LF)
	./$(RES)
install:
	sudo cp $(LF).h $(PREF)/include
	sudo cp lib$(LF).so $(PREF)/lib
	sudo ldconfig
uninstall:
	sudo rm -f $(PREF)/include/$(LF).h
	sudo rm -f $(PREF)/lib/lib$(LF).so
	sudo ldconfig
clean:
	rm $(LF).o lib$(LF).so
cleanall:
	rm $(LF).o $(RES) lib$(LF).so
```

Для запуска прописываем: ./result или sudo make run, если выскакивает ошибка, но компиляция прошла нормально, попробуй sudo chmod +x result
